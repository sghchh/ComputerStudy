# 第一章 信息的表示和处理  
## 一、字数据  

每台计算机都有一个**字长**，表示可以访问的虚拟地址的空间[0, 2^w-1]。  

对于long型数据来说，在32位机器和64位机器上的长度可能是不一样的；而且一般各种语言默认的都是有符号数，而且计算机中有符号数的表示采取的是**补码**的机制。    

### 1. 无符号数和有符号数转换

C语言中提供了**无符号数**类型，并且无符号数和有符号数之间可以直接强制类型转换，二者在bit层次上强制类型转换不会改变任何一个bit的值，只会重新为最高位进行解释而已。  

### 2. 拓展数字的bit表示    

拓展数字发生在由表数范围小的数字类型转换为表数范围大的数字类型时，而拓展数字不会造成数据的错乱，还是会保持原值。

对于**有符号数来说，采取补码数制的符号扩展**，对于无符号数来说，直接往前加0  

### 3. 截断数字  

这种场景发生在表数范围大的数字类型前值转换为表数范围小的数字类型时，也是粗暴的截断。**对于有符号数来说，会对最高位进行重新的解释**  

> 由于Java只支持有符号数，所以在java中有>>和>>>两个右移运算符，前者代表算数右移(高位补符号位)，后者代表逻辑右移(高位补0)

### 4. 零散

#### 移位操作

对于左移操作，只有一种通用的模式，即**低位补0**，因此对于补码表示的有符号数来说，左移有可能会出现正数变为负数或者负数变为正数的情况。

对于右移操作，分为算术右移与逻辑右移：

* 算术右移：左侧补原数的最高位
* 逻辑右移：左侧补0

> 在Java中，移位的实际位数为：想要移位的位数a对数据类型长度的位数b的取余运算，即a mod b

## 二、浮点数  

IEEE浮点数格式：**V = (-1)^sxMx2^E**  

其中：  

* **符号位s**：代表符号位，1代表为负数，0代表为正数  
* **尾数(significand)**：代表小数位的值，其范围是，而上式中的M的表数范围是[1, 2)，所以**尾数只表示M的小数部分**，在float中为第0到第22位表示小数位；在double中为第0位到第51位。(**注意：由于表示的是小数位，此时该部分的最高位权重的是2的-1次幂**)  
* **阶码(exponent)**：上面的式子中E用来给M进行加权，而权重就为2^E，而V最终的值是Mx2^E。阶码在float中为第23位到第30位；在double中为第52位到第62位。(注意：阶码的各个bit为表示的数值大小并不是E，还有一个偏置在下文中会讲)  

在该浮点数表示中，分为了几类数据：规格化、非规格化、无穷大、NAN  

### 1. 规格化数  

定义：**阶码所在的bit位不全为零且不全为1(float下不为255，double下不为2047)**    

此类数据是最常见的情况。但是，注意上文中提到了，阶码表示的数值并不是E的大小，还有一个偏置bias：  
* **E = e -bias**：其中e即为阶码表示的大小，在规格化数中e的范围float:[1, 254],double:[1, 2046];而bias的值为2^(n - 1) - 1其中n代表阶码的位数，在float为8位长度(bias = 128 - 1)，在double为10位长度(bias = 1024 - 1)  

经过这个偏执，我们发现E的范围为[-126, 127]或者[-1022, 1023]；所以浮点数中M的权重为2^E

### 2. 非规格化数  

定义：**阶码所在的bit为全为0**  

此时，虽然e为0，但是此时的E并不是0-bias，而是**1-bias**  

非规格化的数通常**用来表示非常接近0.0的数**  

### 3. 特殊值  

NAN定义：阶码所在的bit为全为1，且尾数不为0  
无穷：阶码所在的bit位全为1，尾数为0  

### 4. 浮点数的精度问题  

可以看出，由于一个小数可能在一个float或者double的表数范围内，但是由于小数位的长度可以很长，所以会出现精度的问题，而出现精度不够的情况下，**计算机会进行舍入操作**，这样一来就产生了精度的丢失，在一些情况下可能会产生意想不到的问题。  

计算机默认的舍入操作是**向偶舍入**，即保留的目标位数后面的bit位，如果大于其表数范围的一半则直接进位；若小于一半则直接舍去；若等于一半则是否进位要看此时保留的目标位数是否是偶数，如果是偶数则舍去，否则进位。  
    
也就是说加入多余的bit位为有n位，只要他们大于100...(n - 1个0)就会进位，小于就会舍去，如果等于那么就要看1的前一位是0还是1，如果是0说明是偶数，则舍去，如果是1说明是奇数则进位。  

比如：我们对一下的数保留1位小数：10.101、10.111、10.110、10.010，结果分别是10.1、11.0、11.0、10.0  

### 5. 实例  

说的再多也不如代码展示来的实际：  

#### 精度缺失问题  

	public static void main(String[] args) {
	    double a = (1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 + 0.1);
	    double b = 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0;
	    System.out.println(a - b);
	}    
	  
	--------------
	output:0.0

首先我们先来看b在IEEE的浮点数表示中各个bit为应该是什么，很简单5个1024相乘，那就是2的50次幂，而double类型的尾数bit位为0到51，所以其长度为52位，而这里b的值就占据了50位，很明显只需要E为50，则b的尾数bit全为0即可；对于a来说，由于1024的五次幂直接使得a的尾数bit前50个全为0，E同样为50，此时a还剩下0和1的bit可以使用，注意由于E为50，Mx2^E代表右移了50个bit，所以此时表示a小数部分的起始bit就是尾数中标号为1和0的bit位了，而此时精度就只有2的-2次幂，也就是四分之一(0.25)了，此时a最后加的0.1没有办法表示了，所以最后的输出a-b会是0  

	public static void main(String[] args) {
	    double a = (1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 + 0.25);
	    double b = 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0;
	    System.out.println(a - b);
	}  
	  
	--------------
	output:0.25  

而此时a加了0.25，精度刚好可以，所以能够正确输出  

#### 舍入现象  

	public static void main(String[] args) {
	    double a = (1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 + 0.375);
	    double b = 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0;
	    System.out.println(a - b);
	}  
	  
	-------------
	output：0.5  

此时a的**小数部分的二进制表示为011**，由于精度只能够到达01，所以最后的1就会执行舍入，根据上面的向偶舍入的规则，此时应该进位(**因为01以1结尾，是奇数**)，所以最终的小数部分的二进制表示为10，也就是输出的0.5了  

	public static void main(String[] args) {
	    double a = (1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0 + 0.625);
	    double b = 1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0;
	    System.out.println(a - b);
	}  
	  
	-------------------
	output：0.5  

此时a的**小数部分的二进制表示为101**，同样根据向偶舍入的规则，因为10表示一个偶数，所以此时发生舍弃，所以最终是输出0.5

