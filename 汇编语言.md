#第一章 基础知识

### 1. 机器语言与汇编语言

机器语言由一系列的01比特组成，不同的微处理器，由于硬件和结构的不同，需要用不同的电平脉冲控制，所以**不同的微处理器要有自己的机器指令集，也就是及其语言**。

> 注意：不同的机器，其机器语言可能不同，即机器指令集会不同

而汇编语言就是便与记忆的机器语言的书写格式。

### 2. 汇编语言的组成

1. 汇编指令：机器指令的助记符
2. 伪指令：没有对应的机器指令，由编译器执行，计算机并不执行
3. 其他符号：如+、-等，由编译器识别

> 两个概念：
>
> 机器指令集=机器语言
>
> 汇编指令=机器指令的助记符
>
> 汇编指令集！=汇编语言

### 3. 存储器与存储单元

存储器即内存，向CPU提供指令与数据；存储器由内存单元组成，一个存储单元可以存储一个字节的数据，存储单元从0开始标号，我们说的内存地址就指向一个存储单元。

### 4. 总线

外部总线包含：数据、地址、控制总线

* 地址总线：地址总线的宽度说明了CPU可以寻址的空间范围，同样是内存地址空间
* 数据总线：数据总线的宽度决定了CPU与外界的数据传送速度
* 控制总线：决定CPU对某一个内存区域是执行何种操作

> 地址总线的长度的2次幂代表内存地址空间？那后面的段地址和偏移地址是怎么回事？

### 5. 内存地址空间

内存地址空间被划分为多个区域，供主存储器、显存地址空间、各类BIOS空间等使用。

#### 几种物理实体

1. 主板：主板上链接各个核心器件，起链接作用的正是总线；器件有CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。

2. 接口卡：CPU不直接控制外设，而是直接控制各个扩展插槽上的接口卡，而接口卡直接控制各种外设如打印机、显示器等。所以CPU是间接控制各个外设。

3. 各类存储器芯片：

   1. RAM：主随机存储器就是我们可用的那一部分主存(注意：并不是主存，而是主存的一部分)
   2. 装有BIOS的ROM：BIOS是主板和接口卡厂商提供的软件系统
   3. 接口卡上的RAM：某些接口卡需要使用到RAM作为其设备的缓存，比如显卡

   所以我们的主存由上面各种存储设备组成，是一个逻辑实体。

### 6. 端口

在PC机中，CPU通过总线连接很多中芯片，这些芯片中都有一组可以由CPU读写的寄存器，这些寄存器都和CPU的总线相连，CPU将这些寄存器作为端口，对他们进行编址，从而产生一个**端口地址空间**，其地址范围为0-65535。

CPU对端口进行读写的指令只有**in和out**，而且其数据只能通过寄存器ax或者al(8位传递时)传递：

```c
in al,20h         # 从20h号端口读入字节
out 20h,al		  # 向20h端口写入字节
```



# 第二章 寄存器

## 一、通用寄存器

8086CPU所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX常用来存放一般数据，被称为通用寄存器。为了兼容老版本的CPU，他们各自**可以拆为两个寄存器使用**，如AX可以分为AH和AL。

> 注意，在使用指令操作时，保证操作数为统一尺度的寄存器，如mov ax，bx，而不可以是mov ah，bx；针对寄存器拆分这一点，好像只有这四个通用寄存器可以拆分，也算是他们的一大特点。

## 二、段地址寄存器

在8086CPU中地址总线为20位，而CPU却是16位的，因此在计算目标内存的物理地址时，**CPU能够一次处理、传输、暂存的信息最大长度为16位**，而地址总线需要20位，所以**计算物理地址采用“段地址x16+偏移地址”的方式来生成一个20位的物理地址（其中段地址x16=基础地址）**。有两点需要注意：

1. 段的起始地址：段的起始地址即为基础地址，所以一个段的起始地址必然是16的倍数
2. 偏移地址的长度为16位，因此一个段的最大长度为16位地址的寻址能力64KB

> **CPU的位数代表内部总线传递的数据的位数；而内存空间大小由外部总线中的地址总线的位数决定**
>
> Q：如果CPU的位数与地址总线的宽度相等，是不是就不需要基础地址了？

8086CPU中有4个段地址寄存器：CS、DS、SS、ES。他们虽然保存的都是段地址寄存器，但是使用的场景不同。

### 1. CS与IP  

CS段地址寄存器与IP寄存器二者搭配，共同决定CPU要执行的指令的地址，**IP寄存器中保存的是偏移地址**。设CS中的内容为M，IP中的内容为N，那么CPU需要执行的下一个指令位于Mx16+N处。  

在程序的执行过程中，IP寄存器的值自动增加不是简单的增加1，而是根据本次执行的指令及其所需要的操作数决定的，即IP寄存器的值可能一次增加2、也可能增加3.

> 当CPU执行完一个指令之后，IP寄存器会根据该指令所需的操作数的个数a，自动增加(a+1)，其中的1代表指令本身需要一个字节位置

通过CS和IP寄存器，8086CPU工作过程可以认为是：

1. 从CS：IP指向的内存单元读取指令，读取的指令进入到指令缓存器
2. IP=IP+所读取指令的长度（长度以字节为单位），从而指向下一个指令
3. 执行指令。转到步骤1，重复

#### **修改CS和IP寄存器的内容**

想要修改这两个寄存器的内容即代表更改执行的代码语句，在编程概念上显然可以通过跳转来实现，对应的汇编指令为jmp指令：

1. jmp 段地址：偏移地址  指令可以同时更改两个寄存器
2. jmp 某一个合法寄存器  指令可以用寄存器的值修改IP

### 2. DS与[]

CS寄存器用来指示CPU执行的命令的地址，而**DS寄存器的作用是在CPU想要读写某一个内存单元的时候作为段地址**。而涉及到访问数据的指令都会有多个操作数，**或是立即数、或是取寄存器内容、或是取内存单元内容**

```c
mov bx, 1000H
mov ax, bx
mov ax, [1]
```

对于立即数和去寄存器内容没什么好说的，对于取内存单元内容就需要提一下DS的作用了，此时DS作为段地址，而“[]”中的内容就作为偏移地址了，二者共同指向某一个内存单元地址。

> CS与DS的区别：CS和DS都是表示基础地址，但是CS用于在访问指令段的时候使用，而DS用于在访问数据段的时候使用
>
> 实际上更一般的理解是"[]"的含义是将其包含的内容作为偏移地址，如果是一个立即数那么偏移地址就为该数；如果是一个寄存器，那么偏移地址就为寄存器的内容。

在汇编中，还提供了寄存器与立即数的结合的方式产生偏移地址：[bx+idata]，即偏移地址的值为(bx)+idata。

si和di是另外两个寄存器，他们的作用和bx作为偏移地址的用法是一样的，且二者可以各自与bx结合：

```c
mov ax,[si]
mov ax,[si+2]
mov ax,[bx+si]
# 注：si可以换成di
```

我们可以引申得到另外两种产生偏移地址的方式：[bx+si]、[bx+si+idata]、[bx+di]、[bx+di+idata]

> si和di与bx一大不同点是si与di不能被拆成8位寄存器使用，而bx可以拆为bh和bl

#### 偏移地址小结

可以作为偏移地址的寄存器有：**bx、si、di、bp(前面未介绍过)**，其他的寄存器不可作为偏移地址使用，如mov bx,[ax]是不可以的；而上面四个寄存器可以单独使用，如果想要两两搭配的话只有四种组合：**bx和di、bx和si、bp和si、bp和di**

> bx和bp二者更像是相对应的，区别就是**只要涉及到使用bp，那么其段地址采用的是ss寄存器的内容**，而如果没有使用到bp，那么采用的是ds寄存器的内容

### 3. SS与SP

上面介绍了两个段地址寄存器，这里再介绍另一个段地址寄存器：SS，**SS段地址寄存器用来与SP寄存器搭配，二者共同指向一个内存单元，代表栈顶**。

因此在CPU执行push和pop指令时，栈顶的地址都是通过SS与SP两个寄存器合成的。在执行push指令时，栈顶的地址是从地址大的往地址小的方向增长的。所以在执行push ax过程中，SP的变化为：

1. SP=SP-2（此时为操作一个字）
2. 将ax的内容送入SS：SP

### 4. es

es寄存器为中断处理程序的段地址寄存器

### 5. 段前缀

对于一些指令来说，其操作的内存空间地址的段地址一般会默认在上述几种段地址寄存器中的一个，比如代码段的段地址在CS中，数据段的段地址在DS中等；也可以显式地指示段地址所在的寄存器（不过一般用在访问内存时，好像影响不了cs、ss和es）：

```c
mov ax,cs:[2]
```

上述使用中就指明了段地址为cs，而不再是默认的ds了。

## 三、标志寄存器

标志寄存器的作用是指导CPU在执行某些指令时的动作

### 1. pushf和popf

这两个指令的功能分别是将标志寄存器的值压入栈和弹出栈

# 第三章 汇编指令

## 一、伪指令

伪指令没有对应的机器指令，在编译过程中编译器通过伪指令来完成编译工作。一般来说，伪指令用来初始化一些寄存器，如段寄存器；还可以标致某一段（代码段或者数据段）的开始和结束。

### 1. 定义段

在程序中有代码段、数据段、栈段三种不同的段，而**伪指令“标号 segment”与“标号 ends”用来定义段开始和段结束**。

对于代码段来说，就是一对汇编指令；而对于数据段来说，需要定义一堆数据，常用的定义数据长度的指令有：dd、dw、db，分别代表双字、字、字节长度的数据；以上三个可以和dup联合使用定义重复数据。

```c
data segment
	dw 0,0,0,0
	dw 4 dup(0)
data ends
```

上面两行的作用是重复的。

### 2. 程序结束符

不同于段结束的“标号 ends”，直接一个end就表示该汇编源程序的结束；同时，**"end 标号"**则告诉编译器，标号处是程序的入口，在exe文件被夹在进内存时，IP会指向标号代表的程序入口的偏移地址。

### 3. 初始化寄存器

assume：通过标号将特定的段寄存器设置为该标号所代表的的段的起始地址

### 4. 程序返回

```c
mov ax，4c00H
int 21H
```

## 二、常见指令与操作符

### 1. loop

bx作为一个通用寄存器，其经常和loop指令搭配。[bx]表示一个偏移地址，这个地址为bx寄存器的内容，而此时的段地址保存在ds中。

cx也是一个通用寄存器，在loop指令中，cx通常初始化为循环的次数，当cx中的值减为0的时候就以为这循环终止。

loop指令的格式为：**loop 标号**，其执行过程为：

1. (cx)=(cx)-1
2. 如果(cx)为0则跳出循环，继续执行后面的指令；否则跳转到标号处执行

### 2. X ptr

在汇编中，可以使用不同的寄存器来表明操作数据的长度，如mov ax，1则说明了1是一个16位数据，而mov al，1则是一个8位。当指令的操作数中不含有寄存器时，我们如何指定操作数的长度呢？就是通过：**X ptr操作符，其中X可以为word或者byte**，如mov word ptr ds:[0],1.

### 3. 跳转指令

##### 3.1 操作符offset

操作符offset用于获取标号的偏移地址：**“offset 标号”**。

##### 3.2 jmp

jmp指令在前面将cs段寄存器的时候提到过，这里要再次介绍其另一种用法：**“jmp short 标号”**，可以将ip寄存器的内容设置为标号处的偏移地址，**注意这种跳转并不是直接将cs：ip指向标号处，而是将ip修改一个偏移量，这个偏移量是编译器根据当前ip与标号处的地址进行计算得来的**。

还有一种**“jmp far ptr 标号”**，这种转移是一种远转移，**使用标号处的段地址与偏移地址分别更改cs寄存器和ip寄存器**

上面两种转移：近转移和远转移，或者说段内转移和段间转移，有各自对应的不同版本：

* jmp word ptr 内存单元地址：对应段内转移
* jmp dword ptr 内存单元地址：对应段间转移，从内存单元地址处开始存放的两个字，高地址处时目的段地址，低地址处时目的偏移地址 

##### 3.3 jcxz

该指令是有条件转移指令，是一个短转移，指令格式为：**jcxz 标号(如果(cx)=0,转移到标号处执行)**  

##### 3.4 loop

循环指令也是短转移，指令格式为：**loop 标号((cx)=(cx)-1,如果(cx)!=0,转移到标号处执行)**

##### 3.5 call

call指令也可以实现跳转，其使用方式多样。

**“call 标号”**：这种形式的跳转也是通过计算相对于当前位置的偏移来算的，其操作过程如下：

1. (sp)=(sp)-2,((ss)x16+(sp))=(ip)
2. (ip)=(ip)+16位位移，该位移是有编译程序在编译时计算出的，为标号处的地址-call指令后第一个字节的地址  

这种形式的跳转思路为：首先将当前ip压入栈，然后跳转到标号位置；很明显，没有改变cs的内容，所以这是一个段内转移。

**“call far ptr 标号”**：这种形式的跳转也是通过计算相对于当前位置的偏移来算的，其操作过程如下：

1. (sp)=(sp)-2,((ss)x16+(sp))=(cs),(sp)=(sp)-2,((ss)x16+(sp))=(ip)
2. (cs)=标号所在的段的段地址，(ip)=标号所在段中的偏移地址

很明显，这种用法实现的是段间转移。

同样，类似于jmp指令，call也有对应的如下两种使用形式：

* call word ptr ds:idata
* call dword ptr ds:idata

##### 3.6 ret和retf

ret和retf二者都是使用栈的数据，前者只修改ip，后者修改cs与ip：

ret指令过程如下(等同于pop ip)：

1. (ip)=((ss)x16+(sp))  
2. (sp)=(sp)+2

retf指令过程如下(等同于pop ip，pop cs)：

1. (ip)=((ss)x16+(sp))  
2. (sp)=(sp)+2
3. (cs)=((ss)x16+(sp))  
4. (sp)=(sp)+2



很明显，call将(ip)压入栈，而ret将栈中的数据放入(ip)二者可以搭配使用实现子程序调用，然后返回到调用者。

##### 3.7 有条件跳转

结合标志寄存器flag，汇编中提供了一些有条件跳转的指令：

* je：等于则转移，zf=1
* jne：不等于则转移，zf=0
* jb：低于则转移，cf=1
* jnb：不低于则转移，cf=0
* ja：高于则转移，cf=0且zf=0
* jna：不高于则转移，cf=1或zf=1

# 第四章 中断处理

CPU要具有一种能力：当CPU外部或内部产生某些特殊信息时，能够暂停当前的任务，立即对这些信息进行处理，处理完毕后在返回之前暂停处继续。这些信息就叫做**中断信息**。

在CPU中，中断信息被分为很多种类别，不同的类别使用不同的信息标号，叫做**中断类型码**，所有的中断信息码使用一个字节即可包含完毕。

而根据中断信息产生响应，需要对中断信息进行处理，该处理程序就叫做**中断处理程序**。

CPU想要中止当前的任务，跳转到中断处理程序处，那么必须将CS：IP设置为相应中断处理程序的入口，因此CPU内部维护了一个**中断向量表**，通过这个中断向量表可以更具中断类型码查询相应的中断处理程序的入口。在CPU中，中断向量表是必须的，而且是固定在某一块内存区域的。  

CPU通过中断类型码找到中断向量，根据其记录的内容设置CS和IP的值，这个过程是CPU自动完成的，叫做**中断过程**。中断过程的流程如下：

1. 获取中断类型码N
2. pushf
3. TF=0，IF=0
4. push CS
5. push IP
6. (IP)=(Nx4),(CS)=(Nx4+2)

中断处理程序就像是子程序一样，其也有一个iret指令用于从中断处理程序中返回：

1. pop IP
2. pop CS
3. popf

> 在上面的中断过程中有一步设置IF和TF为0，其意义何为？
>
> 1. 设置TF为0：TF为1会触发CPU的单步中断过程，如果不设置TF为0的话，那么在进入单步中断处理程序时TF仍然为1，仍然会触发单步中断过程，这样一直嵌套CPU永远卡在了单步中断过程这一步。
> 2. 设置IF为0：IF为1会使得CPU响应可能产生的可屏蔽中断，设置其为0会使得CPU不响应可屏蔽中断。汇编中也提供了指令主动设置IF的标志：
>    1. sti：设置IF=1
>    2. cli：设置IF=0

## 一、内中断

### 1. int指令

int指令的格式为：**int n**，其中n为中断类型码，该功能就是直接引发中断过程。

## 二、外中断

外部中断一般来自于外设，比如键盘输入等；外部中断分为可屏蔽中断和不可屏蔽中断。

### 1. 可屏蔽中断

可屏蔽中断时CPU可以不响应的外中断，CPU是否响应可屏蔽中断要看标志位寄存器IF是否为1，为1则需要响应中断，为0则不响应中断。

### 2. 不可屏蔽中断

该类型的外部中断是CPU必须响应的外中断，其中断类型码为2.







