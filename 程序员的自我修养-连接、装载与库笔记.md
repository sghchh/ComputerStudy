## ELF文件

* 可重定位文件：包含代码和数据，可以被用来链接成可执行文件或者共享目标文件。一般是目标文件或者静态链接库
* 可执行文件：典型的是windows下的exe文件
* 共享目标文件：包含了代码与数据。可以与其他可重定位文件或者共享目标文件链接；也可以通过动态链接器与可执行文件结合来运行。
* 核心转储文件

### 1. 目标文件的格式

目标文件包含两个大部分：

* 头部：包含魔数、机器类型、文件类型、版本等各种信息
* 各种段
* 各种表

### 2. 各种段

不同的段存储不同的内容，常见的段有

* 代码段：存放源代码中的需要执行的指令
* 数据段与bss：存放代码中定义的变量

#### 代码段

使用.text或者.code表示。代码段就是所有函数体中的代码对应的机器语言，唯一需要**特殊注意的是对于函数体中涉及到的、对函数外部全局变量、或者其他函数的调用；由于这两种情况下只能够通过内存地址的形式访问数据，所以对应的指令操作数应该是地址值而不是寄存器**。这就涉及到一个问题，那就是这些地址只有在程序运行时才知道，因此在编译过程中还不知道具体的值，因此在后续步骤中需要对这些地方进行**重定位**

#### 数据段与只读数据段

数据段(.data)中存放**已经初始化了的全局变量和局部静态变量**，而只读数据段(.rodata)中存放**字符串常量、const变量**.

#### bss段

bss段中存放的是**未初始化的全局变量与局部静态变量**。

> 对于将静态变量手动初始化为0值的情况，编译器可能会将其优化、认为其是没有被初始化的而放到bss而不是data段中

### 3. 各种表

#### 段表

段表在ELF中至关重要，段表保存各种段的基本属性，比如段名、段的长度、在文件中的偏移等；编译器、连接器、装载器就是通过段表来定位和访问各个段的内容的。而**段表在ELF文件中的位置由头部中的e_shoff成员指示，该成员指明段表在ELF文件中的起始偏移位置。**

段表实际上就是一个数组，只不过**数组元素为Elf32_Shdr**，其包含了以下成员：

* 段名：是一个整数，指向字符串表中对应位置的字符串
* 段类型：**用来区分是程序段、代码段、数据段、重定位表、符号表、字符串表等类别**。之所以不可以使用段名来区分不同的段，是因为对于我们自定义的段，其名字依然可以明明为text或者data等，所以需要使用段类型来进行区分。
* 段标志：**表示该段在进程虚拟地址空间的属性，是否可写、是否可执行或者是否需要分配空间**
* 段虚拟地址：如果该段可以被加载，那么是**段被加载到进程空间后的虚拟起始地址**
* 段偏移：如果该段在ELF文件中存在，表示**段在该ELF文件中的偏移量**，用来定位该段在ELF文件中的位置。对于bss来说，其在ELF文件中并不存在，所以无意义
* 段长度
* 段链接信息
* 段地址对齐
* 项长度

ELF文件中有多少个段，那么就会有多少个上面所示的表项。

#### 重定位表

**连接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。**这些重定位信息记录在ELF文件的重定位表中。

#### 字符串表

使用字符串表的思想是，字符串的长度不固定，用固定的结构表示它比较困难，**将所有用到的字符串集中起来，使用字符串在表中的偏移来引用字符串**。

> 注意：在C语言中，字符串以\0作为结尾标识，因此在使用偏移来指示字符串时，**只能表示到结尾处的某一段字符串**，比如字符串helloworld，可以在字符串表中同时指代world、orld、rld等，因为他们都是从某一处开始直到字符串的结尾，只需要通过结尾表示就可以确定该字符串的边界，但是却不能表示hello，因为只通过一个开始下标，没法确定该字符串的右边界。

#### 符号表

符号即函数或者变量的标识，在代码编写过程中经常涉及到外部变量或者函数的引用，而我们上面提到了，对于引用的外部变量或者函数，在执行的时候，对应的操作数一定要是他们的地址，而不能是寄存器。而**他们的地址只有在各自定义的文件中才会知道**，所以在**进行链接的过程中引用它们的文件就通过符号表来记录它们的地址**。（注意：符号表包括所有符号，不光是引用外部文件的符号）。

符号的范围如下：

* 本文件定义的全局符号：函数、全局变量等；**其值为它们的地址**
* 本文件引用的全局符号
* 段名：由编译器产生，如.text、.data等，其值为**这些段的起始地址**
* 局部符号：对于链接过程无用

关于符号表中符号值字段的释义如下：

* 在**目标文件**中：符号值代表符号在其所在段中的偏移。
* 在**可执行文件**中：符号值代表符号的虚拟地址。

# 静态链接

* Q:到底何为虚拟地址？虚拟地址的作用？
* 每个进程虚拟地址空间都是4G吗？如果是的话，为啥不都从1号位置开始？

静态链接的作用是将多个目标文件链接成一个**可执行文件**；静态链接分为两步：**空间与地址分配、符号解析与重定位**

#### 空间与地址分配

空间与地址分配有两层含义：首先是空间的分配，指的是多个目标文件中所有信息的整合，具体是相同段的整合，即多个目标文件之间的text会整合成一个，data段也会整合成一个，同时还会搜集所有的符号，从而生成一个新的ELF文件，这就是ELF文件的空间分配。

其次是地址分配，在生成一个可执行文件后，当可执行文件被加载到内存时，他们之间的相对关系就不会发生变动了，所以可以在此分配各自的虚拟地址了。例如：text代码段中起始地址确定之后，剩余的每一个指令都可以根据其在text中相对于text起始位置的偏移来确定自己的虚拟地址；data段也类似。地址分配后，**链接器会更新符号表中各个符号的信息，很重要的信息就是各个符号的值，更新为了他们的虚拟地址**。

> 注意在空间与地址分配的过程中并不是所有的段都会进行分配，例如bss段在ELF文件中并不占有空间，但是会在进程空间中占有内存，因此bss段不需要进行空间分配，只需要进行地址分配；同样对于一些辅助段，其可能只需要进行空间分配，而不需要进行地址分配。因此，**在ELF文件中相连的段，在进行地址分配时便可能变得无序，所以，链接过程中会为每一个段分配起始地址值，段内的指令或者数据会根据各自的起始地址与偏移进行地址分配**。

> 在Linux下，ELF可执行文件默认从地址0x08048000开始分配

关于地址分配的问题，这里只是在虚拟地址上进行分配，并没有实际载入内存，但是进程空间都是遵循一定的格式的，所以这里分配地址空间是可以的。

这里保留一个问题：不同的可执行文件如果他们有的段在连接后的地址产生冲突，那么操作系统在进行映射的时候如何区分？

#### 符号解析与重定位

在文件中引用的其他文件中的全局符号时，在**编译成目标文件时，代码段中对于外部全局符号的使用是预设0或者其他固定的绝对地址值；而当链接进行完之后，这些外部全局符号的位置就会变成真正的地址值**。

链接器想要进行重定位，必须知道哪些指令需要调整？指令的哪些部分需要调整？怎么调整？提供这一点的是**重定位表**，ELF中的重定位表比较特殊，各个段中只要有需要重定位的符号，那么就会单独为该段在ELF中产生一个重定位表，如.rel.data或者.rel.text等。

重定位表也可以看作一个数组，其数组元素有以下成员：

* offset：对于可重定位文件来说，表示需要重定位的符号位于所在段的偏移；而对于可执行文件来说，表示需要修正的位置的第一个字节的虚拟地址。
* info：指示**需要重定位的符号的内容在符号表中的下标**(上面提到过符号表中的元素定义了符号的名字与符号的地址等信息)

# 文件装载

当代操作系统都采用动态装载的原理：**将程序最常用的部分驻留在内存中，一些不太常用的数据存放在磁盘里面**，其中的典型就是**页映射机制**。

页映射机制中，内存和所有磁盘中的数据和指令按照“页“为单位划分成若干个页，之后装载和操作的单位都是页。

装载过程为，**当程序发生页错误时，操作系统从物理内存中分配一个物理页，然后将该“缺页”从磁盘读取到内存中，再设置缺页的虚拟页与物理页之间的映射关系**。而一个可执行文件可能会被分割成多个虚拟页，因此，操作系统需要了解到缺页对应的虚拟页与可执行文件之间的映射关系，**确定这个映射关系是装载过程的关键**。这种映射关系指示保存在操作系统内部的一个**数据结构**。

当发生页错误的时候，CPU将控制权交给操作系统，操作系统有专门的页错误处理例程来处理这种情况，此时就通过上面提到的数据结构确定缺页部分在可执行文件中的偏移，然后将该缺页虚拟页转载到分配的物理页上，再将控制权还给进程。

**Linux中将进程虚拟空间中的一个段叫做虚拟内存区域(VMA)，操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映象文件的映射成一个VMA**，一个进程基本上含有如下VMA：

* 代码VMA
* 数据VMA
* 堆VMA
* 栈VMA

![捕获](C:\Users\sgh\Desktop\捕获.PNG)

上图展示了进程虚拟空间中，各个VMA的相对位置关系。

# 内存

应用程序在内存中有如下默认的区域：

* 栈：用于维护函数调用的上下文；通常在用户空间的最高地址分配。
* 堆：用来容纳应用程序动态分配的内存区域；通常位于栈的下方
* 可执行文件映象：存储可执行文件在内存的映象，由装载器在装载时将文件读取到这里。
* 保留区：并不是一个连续的单一的内存区域，而是对内存中受保护的内存区域的总称。
* 动态链接库映射区：用于映射装载的动态链接库。

## 一、栈

栈保存了一个函数调用所需要维护的最小信息，称为栈帧，栈帧一般包含如下几方面内容：

* 函数的返回地址与参数
* 临时变量：包括函数的非静态局部变量与编译器自动生成的其他临时变量
* 保存的上下文：包括在函数调用前后保持不变的寄存器

不同函数的栈帧大小的不同的，因为每个函数的局部变量、参数个数与类型都不尽相同，所以**一个函数对应的栈帧的范围由ebp与esp划定**。esp始终指向栈的顶部，同时也就是指向当前函数活动记录的顶部；相对的，ebp寄存器指向了函数活动记录的一个固定位置，即调用该函数前ebp的值，这样在函数返回后，就可以通过ebp恢复到调用前的值。

![捕获](C:\Users\sgh\Desktop\捕获.PNG)

(顺序为从上至下)

#### 对于返回大对象的实现

对于简单的int返回类型的数据，C语言中直接使用eax寄存器作为返回值的存放位置，而对于8字节的会使用eax与ebx两个寄存器存放返回值；而对于更大的数据，比如一个大数组，那么C语言会在函数返回时使用一个临时的栈上内存区域作为中转，返回值对象首先会被拷贝到该临时区域，然后再从该临时区域拷贝到调用函数的局部变量区域完成调用，因此**该对象会被拷贝两次**。

## 二、堆

在C语言中，并不是每次申请分配空间都是发生系统调用，管理者堆空间分配的往往是程序的运行库。运行库相当于是想操作系统“批发”了一块较大的堆空间，然后“零售”给程序用，当全部“售完”或者程序有大量的内存需求时，再根据实际需求向操作系统“进货”。运行库通过堆的分配算法来管理堆空间。(注意：堆的分配算法是运行库中运行的)

### 1. 两个系统调用

Linux提供两个系统调用来分配堆空间：**brk与mmap**。

**brk的作用是扩大或者缩小数据段(data段+bss段)，扩大的部分可以用来做堆空间。mmap用来向操作系统申请一段虚拟地址空间。**

**glibc与malloc函数处理用户的空间请求的原理为：对于小于128kb的请求来说，会在原有的堆空间中按照分配算法为它分配空间；对于大于128k的请求，会使用mmap函数为它申请一块空间分配给用户。(malloc申请的空间的起始地址大小必须是系统页的大小的整数倍)**

### 2. 堆分配算法

#### 空闲链表

思想是把空闲的内存块按照链表的方式连接起来，当用户申请时，就遍历链表找到一块空间够大的区域从中分割出足够的空间。

#### 位图

将堆内存按照固定单位大小划分成多个块，分配时只能分配整数个块，其中用户得到的所有块中第一个块为头部、其他的为主体；因此堆内存中的每一个块都只会有三种状态：**头部、主体、空闲**。因此，每一个块的状态可以用2bit位表示，所有的块可以用N bit位表示，称为一个位图。





