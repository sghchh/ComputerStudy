## ELF文件

* 可重定位文件：包含代码和数据，可以被用来链接成可执行文件或者共享目标文件。一般是目标文件或者静态链接库
* 可执行文件：典型的是windows下的exe文件
* 共享目标文件：包含了代码与数据。可以与其他可重定位文件或者共享目标文件链接；也可以通过动态链接器与可执行文件结合来运行。
* 核心转储文件

### 1. 目标文件的格式

目标文件包含两个大部分：

* 头部：包含魔数、机器类型、文件类型、版本等各种信息
* 各种段
* 各种表

### 2. 各种段

不同的段存储不同的内容，常见的段有

* 代码段：存放源代码中的需要执行的指令
* 数据段与bss：存放代码中定义的变量

#### 代码段

使用.text或者.code表示。代码段就是所有函数体中的代码对应的机器语言，唯一需要**特殊注意的是对于函数体中涉及到的、对函数外部全局变量、或者其他函数的调用；由于这两种情况下只能够通过内存地址的形式访问数据，所以对应的指令操作数应该是地址值而不是寄存器**。这就涉及到一个问题，那就是这些地址只有在程序运行时才知道，因此在编译过程中还不知道具体的值，因此在后续步骤中需要对这些地方进行**重定位**

#### 数据段与只读数据段

数据段(.data)中存放**已经初始化了的全局变量和局部静态变量**，而只读数据段(.rodata)中存放**字符串常量、const变量**.

#### bss段

bss段中存放的是**未初始化的全局变量与局部静态变量**。

> 对于将静态变量手动初始化为0值的情况，编译器可能会将其优化、认为其是没有被初始化的而放到bss而不是data段中

### 3. 各种表

#### 段表

段表在ELF中至关重要，段表保存各种段的基本属性，比如段名、段的长度、在文件中的偏移等；编译器、连接器、装载器就是通过段表来定位和访问各个段的内容的。而**段表在ELF文件中的位置由头部中的e_shoff成员指示，该成员指明段表在ELF文件中的起始偏移位置。**

段表实际上就是一个数组，只不过**数组元素为Elf32_Shdr**，其包含了以下成员：

* 段名：是一个整数，指向字符串表中对应位置的字符串
* 段类型：**用来区分是程序段、代码段、数据段、重定位表、符号表、字符串表等类别**。之所以不可以使用段名来区分不同的段，是因为对于我们自定义的段，其名字依然可以明明为text或者data等，所以需要使用段类型来进行区分。
* 段标志：**表示该段在进程虚拟地址空间的属性，是否可写、是否可执行或者是否需要分配空间**
* 段虚拟地址：如果该段可以被加载，那么是**段被加载到进程空间后的虚拟起始地址**
* 段偏移：如果该段在ELF文件中存在，表示**段在该ELF文件中的偏移量**，用来定位该段在ELF文件中的位置。对于bss来说，其在ELF文件中并不存在，所以无意义
* 段长度
* 段链接信息
* 段地址对齐
* 项长度

ELF文件中有多少个段，那么就会有多少个上面所示的表项。

#### 重定位表

**连接器在处理目标文件时，需要对目标文件中某些部位进行重定位，即代码段和数据段中那些对绝对地址的引用的位置。**这些重定位信息记录在ELF文件的重定位表中。

#### 字符串表

使用字符串表的思想是，字符串的长度不固定，用固定的结构表示它比较困难，**将所有用到的字符串集中起来，使用字符串在表中的偏移来引用字符串**。

> 注意：在C语言中，字符串以\0作为结尾标识，因此在使用偏移来指示字符串时，**只能表示到结尾处的某一段字符串**，比如字符串helloworld，可以在字符串表中同时指代world、orld、rld等，因为他们都是从某一处开始直到字符串的结尾，只需要通过结尾表示就可以确定该字符串的边界，但是却不能表示hello，因为只通过一个开始下标，没法确定该字符串的右边界。

#### 符号表

符号即函数或者变量的标识，在代码编写过程中经常涉及到外部变量或者函数的引用，而我们上面提到了，对于引用的外部变量或者函数，在执行的时候，对应的操作数一定要是他们的地址，而不能是寄存器。而**他们的地址只有在各自定义的文件中才会知道**，所以在**进行链接的过程中引用它们的文件就通过符号表来记录它们的地址**。（注意：符号表包括所有符号，不光是引用外部文件的符号）。

符号的范围如下：

* 本文件定义的全局符号：函数、全局变量等；**其值为它们的地址**
* 本文件引用的全局符号
* 段名：由编译器产生，如.text、.data等，其值为**这些段的起始地址**
* 局部符号：对于链接过程无用

关于符号表中符号值字段的释义如下：

* 在**目标文件**中：符号值代表符号在其所在段中的偏移。
* 在**可执行文件**中：符号值代表符号的虚拟地址。

# 静态链接

* Q:到底何为虚拟地址？虚拟地址的作用？
* 每个进程虚拟地址空间都是4G吗？如果是的话，为啥不都从1号位置开始？

静态链接的作用是将多个目标文件链接成一个**可执行文件**；静态链接分为两步：**空间与地址分配、符号解析与重定位**

#### 空间与地址分配

空间与地址分配有两层含义：首先是空间的分配，指的是多个目标文件中所有信息的整合，具体是相同段的整合，即多个目标文件之间的text会整合成一个，data段也会整合成一个，同时还会搜集所有的符号，从而生成一个新的ELF文件，这就是ELF文件的空间分配。

其次是地址分配，在生成一个可执行文件后，当可执行文件被加载到内存时，他们之间的相对关系就不会发生变动了，所以可以在此分配各自的虚拟地址了。例如：text代码段中起始地址确定之后，剩余的每一个指令都可以根据其在text中相对于text起始位置的偏移来确定自己的虚拟地址；data段也类似。地址分配后，**链接器会更新符号表中各个符号的信息，很重要的信息就是各个符号的值，更新为了他们的虚拟地址**。

> 注意在空间与地址分配的过程中并不是所有的段都会进行分配，例如bss段在ELF文件中并不占有空间，但是会在进程空间中占有内存，因此bss段不需要进行空间分配，只需要进行地址分配；同样对于一些辅助段，其可能只需要进行空间分配，而不需要进行地址分配。因此，**在ELF文件中相连的段，在进行地址分配时便可能变得无序，所以，链接过程中会为每一个段分配起始地址值，段内的指令或者数据会根据各自的起始地址与偏移进行地址分配**。

> 在Linux下，ELF可执行文件默认从地址0x08048000开始分配

#### 符号解析与重定位

在文件中引用的其他文件中的全局符号时，在**编译成目标文件时，代码段中对于外部全局符号的使用是预设0或者其他固定的绝对地址值；而当链接进行完之后，这些外部全局符号的位置就会变成真正的地址值**。

链接器想要进行重定位，必须知道哪些指令需要调整？指令的哪些部分需要调整？怎么调整？提供这一点的是**重定位表**，ELF中的重定位表比较特殊，各个段中只要有需要重定位的符号，那么就会单独为该段在ELF中产生一个重定位表，如.rel.data或者.rel.text等。

重定位表也可以看作一个数组，其数组元素有以下成员：

* offset：对于可重定位文件来说，表示需要重定位的符号位于所在段的偏移；而对于可执行文件来说，表示需要修正的位置的第一个字节的虚拟地址。
* info：指示**需要重定位的符号的内容在符号表中的下标**(上面提到过符号表中的元素定义了符号的名字与符号的地址等信息)





