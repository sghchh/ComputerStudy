## ELF文件

* 可重定位文件：包含代码和数据，可以被用来链接成可执行文件或者共享目标文件。一般是目标文件或者静态链接库
* 可执行文件：典型的是windows下的exe文件
* 共享目标文件：包含了代码与数据。可以与其他可重定位文件或者共享目标文件链接；也可以通过动态链接器与可执行文件结合来运行。
* 核心转储文件

### 1. 目标文件的格式

目标文件包含两个大部分：

* 头部：包含魔数、机器类型、文件类型、版本等各种信息
* 各种段
* 各种表

### 2. 各种段

不同的段存储不同的内容，常见的段有

* 代码段：存放源代码中的需要执行的指令
* 数据段与bss：存放代码中定义的变量

#### 代码段

使用.text或者.code表示。代码段就是所有函数体中的代码对应的机器语言，唯一需要**特殊注意的是对于函数体中涉及到的、对函数外部全局变量、或者其他函数的调用；由于这两种情况下只能够通过内存地址的形式访问数据，所以对应的指令操作数应该是地址值而不是寄存器**。这就涉及到一个问题，那就是这些地址只有在程序运行时才知道，因此在编译过程中还不知道具体的值，因此在后续步骤中需要对这些地方进行**重定位**

#### 数据段与只读数据段

数据段(.data)中存放**已经初始化了的全局变量和局部静态变量**，而只读数据段(.rodata)中存放**字符串常量、const变量**.

#### bss段

bss段中存放的是**未初始化的全局变量与局部静态变量**。

> 对于将静态变量手动初始化为0值的情况，编译器可能会将其优化、认为其是没有被初始化的而放到bss而不是data段中

### 3. 各种表

#### 段表

段表在ELF中至关重要，段表保存各种段的基本属性，比如段名、段的长度、在文件中的偏移等；编译器、连接器、装载器就是通过段表来定位和访问各个段的内容的。而**段表在ELF文件中的位置由头部中的e_shoff成员指示，该成员指明段表在ELF文件中的起始偏移位置。**

段表实际上就是一个数组，只不过**数组元素为Elf32_Shdr**，其包含了以下成员：

* 段名：是一个整数，指向字符串表中对应位置的字符串
* 段类型：用来区分是程序段、代码段、数据段、重定位表、符号表、字符串表等类别
* 段标志：**表示该段在进程虚拟地址空间的属性，是否可写、是否可执行或者是否需要分配空间**
* 段虚拟地址：**段被加载到进程空间后的虚拟起始地址**
* 段偏移：**段在该ELF文件中的偏移量**，用来定位该段在ELF文件中的位置
* 段长度
* 段链接信息
* 段地址对齐
* 项长度

ELF文件中有多少个段，那么就会有多少个上面所示的表项。

#### 重定位表



#### 字符串表

使用字符串表的思想是，字符串的长度不固定，用固定的结构表示它比较困难，**将所有用到的字符串集中起来，使用字符串在表中的偏移来引用字符串**。

> 注意：在C语言中，字符串以\0作为结尾标识，因此在使用偏移来指示字符串时，**只能表示到结尾处的某一段字符串**，比如字符串helloworld，可以在字符串表中同时指代world、orld、rld等，因为他们都是从某一处开始直到字符串的结尾，只需要通过结尾表示就可以确定该字符串的边界，但是却不能表示hello，因为只通过一个开始下标，没法确定该字符串的右边界。

#### 符号表

符号即函数或者变量的标识，在代码编写过程中经常涉及到外部变量或者函数的引用，而我们上面提到了，对于引用的外部变量或者函数，在执行的时候，对应的操作数一定要是他们的地址，而不能是寄存器。而他们的地址只有在各自定义的文件中才会知道，所以在**进行链接的过程中引用它们的文件就通过符号表来记录它们的地址**。（注意：符号表包括所有符号，不光是引用外部文件的符号）。

符号的范围如下：

* 本文件定义的全局符号：函数、全局变量等；**其值为它们的地址**
* 本文件引用的全局符号
* 段名：由编译器产生，如.text、.data等，其值为**这些段的起始地址**
* 局部符号：对于链接过程无用

### 3. 静态链接

* Q:到底何为虚拟地址？虚拟地址的作用？
* 每个进程虚拟地址空间都是4G吗？如果是的话，为啥不都从1号位置开始？

静态链接的作用是将多个目标文件链接成一个