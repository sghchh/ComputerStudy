# C和指针学习笔记

## 一、C语言基础知识

### 1. 数据类型

C中有4中基本数据类型：整型、浮点型、指针和聚合类型（常见的如数组和结构等）。

> **注意：在C语言中，指针算作一种基本类型，聚合中的数组也算是基本类型**  

#### 整型

C语言中的整型包括有符号与无符号两种表示方式，不过默认情况下都是有符号的，想要使用无符号整型数，则需要增加**unsigned修饰符**。同样，在C语言中，对于各种整型数的长度也没有做明确的规定，只给出了下限：

* char：最小为8位长度
* short：最小为16位长度
* int：最小为16位长度
* long：最小为32位长度

> 注意：在c语言中最短的就是char类型了，没有byte类型

在C语言中，枚举类型中的变量实际上也都是整型值，所以一个整型变量可以被赋值为一个枚举类型，同样某一个枚举类型也可以被初始化为一个整型字面量：

```c
enum Test{ONE = 10, TWO = 50, THREE = 100}
int a = Test.ONE
```

#### 浮点数

C语言中的浮点数有：**float、double、long double**三种；在默认情况下为double

#### 指针

声明指针类型的变量有两种书写方式：

```c
int* a；
int *a；
```

推荐使用第二种方式，因为在同时声明多个指针变量的时候第二种方式更加明确、更加符合我们的第一印象：

```c
int* a, b, c;       // 只有a是一个指针类型变量，b和c都是int型
int *a, *b, *c;     // a，b，c都是int型指针变量
```

#### 字符

这里只介绍几个特殊字符：

* \n:换行符
* \r:回车符
* \ddd:ddd为三个八进制数，表示ddd这个数值所代表的字符
* \xddd:这里的ddd为三个16进制数，同样也是数值所代表的字符
* '\0':这个字符之所以特殊，是因为它是字符串的结尾字符，又叫NUL

> 注意：0ddd代表八进制表示的整数，0xddd代表十六进制表示的整数；而这里用他们表示字符，则将0替换成转义字符

### 2. typedef

这个关键字可以将**类型进行重命名**：

```c
typedef char *pointer_char;
pointer_char a;  // 此时变量a的实际类型为指向char类型的指针
```

### 3. 存储类型

变量的存储类型指的是变量值存储的内存类型，在C语言中有三种：

* 普通内存
* 运行时堆栈
* 寄存器

变量的存储类型取决于声明的位置与修饰符：

* 静态变量：此静态变量不同于Java中的静态变量，这里指的是**在代码块外部声明的变量**，静态变量存储在普通内存中，其在程序的执行过程中一直存在。**静态变量在不进行初始化时，会默认初始化为零值**。
* 自动变量：与静态变量相反，在代码块内部声明的变量默认都是自动变量，只有在运行期间所在方法被调用时其内存才会被分配，**可以加上static修饰符(在代码块中static关键字的意义是更改变量的存储类型，而不是链接属性)将其转换为静态变量，从而扩大他们的生存时间**；而对于函数的形参，由于**要支持递归调用，他们的存储类型都是运行时堆栈，不能使用static关键字修饰**

对于自动变量，如果使用**static关键字**修饰的话，其存储类型会变为静态存储的普通内存；而如果使用**register关键字**进行修饰的话，其存储类型会变为寄存器。

> 自动变量的初始化开销要更大，因为其存储位置是在运行时才知道的，所以**自动变量没有默认初始值**，而其初始化语句在运行期间的执行也占用时间；相对于来说，静态变量的初始化值实际在程序连接时就确认了，在程序载入内存时该变量存放的内存区域就会被初始化值填充上，所以静态变量的初始化语句在运行时不会占用时间。

### 4. 操作符

#### 移位操作符

对于无符号数不管是左移还是右移都是逻辑右移；而对于有符号数来说，左移操作符只需要舍弃左侧出去的部分，右侧补零；而对于右移操作符，默认是算术右移还是逻辑右移由编译器决定。

> 注意：**对于移位操作符和按位操作符来说，左右两侧的操作数都必须是整型**

#### sizeof操作符

sizeof操作符返回操作符的长度（以字节为单位）；**注意，sizeof操作符后面接表达式时，由于判断长度并不需要表达式的结果，所以表达式并不会被执行**。  

```C
int a = 0, b = 1;
sizeof(a = b + 1);   // 执行完后a的值还是
```

#### 关系操作符

在C语言中，**关系操作符的结果是一个整型值（0代表为假，1代表为真）**，并不是布尔值

```c
int a = 0, b = 1, c = 2;
a = b < c;   // 这个语句是合法的，并且a的值会变为1
```

#### 逗号操作符

逗号操作符将两个或多个表达式分割开来，这些表达式自左向右逐个进行求值，整个逗号表达式的值就是最后那个表达式的值。

### 5. 函数原型

函数原型的作用是告诉编译器这些以后在源文件中定义的函数的特征；这样，当这些函数被调用时，编译器就能对它们进行准确性检查。

### 6. 变量的作用域与链接属性

唯一要说明的是**文件作用域**：即符号被声明在一个c源文件中，那么该符号的作用域知道源文件尾部；而且，如果该源文件被其他的文件使用include预处理指令包含在了另一个源文件中，那么该符号的作用域将不只是其所在源文件的尾部。

标识符在进行文件链接的时候该如何解释，不光要看标识符的作用域，还要看其**链接属性**：

* external：使用该修饰符修饰的标识符，无论声明多少次、位于几个源文件中，都会链接到同一个实体。**默认情况下，文件作用域的标识符的链接属性为external，可以使用static关键字将该标识符的链接属性更改为internal**。
* internal：属于internal链接属性的标识符只有在同一个源文件内才会链接到同一个实体；可以防止源文件中的函数、变量被其他源文件使用
* none：同一个标识符的不同声明链接为不同实体

> 注意这种链接属性虽然external和internal都有链接到同一个实体的意义，但是这和变量的作用域并不冲突；虽然有一个external或者internal的同名标识符，但是在函数体中，局部同名标识符的会覆盖掉他们，只有没有人可以覆盖他们，他们才会被链接到

## 二、指针

### 1. 指针的值

在C语言中，**一个变量的值就是分配给这个变量的内存位置所存储的数值**，即使是指针类型也不例外，**指针的值就是其所保存的地址值**。

NULL指针是一个特殊的指针变量，表示不指向任何东西；不是所有的编译器都会将未被初始化的指针设置为NULL指针，所以在我们不知道指针该初始化为哪一个地址，那么我们需要显示将其设置为NULL。同时，**对NULL指针进行取内容操作是非法的！！**

```c
int *a;
*a = 12;
```

上面的代码是非法的，因为a指针是为初始化的，所以对a执行取指令操作的结果是未知的。

### 2. 指针与运算符

#### 取内容操作符

取内容操作符，也可以叫做间接访问操作符，**这个操作符的操作数只能是指针变量或者是一个地址值**：

```c
*100 = 1;    // 虽然从间接访问操作符的本意来说，我们可以将其理解为将地址值为100的字节设为1，这看起来没什么问题；但是这是非法的，因为这里的100不是一个地址值，而是一个整型int类型的数据。
*(int *)100 = 1;   // 虽然可以将100强制类型转化，但是不推荐这样做，这是非常危险的写法
```

**当一个变量作为左值时指的是该变量对应的内存区域，而当一个变量作为一个右值时值得是该变量的值**。

```c
int a = 1;   // 假设a所在内存为100
```

那么，当a作为右值时其意义就是1；当a作为左值时，其意义就是地址为100的内存区域。

```c
int a = 1;  // 假设a所在的内存为100
```

但是对于表达式&a来说，它作为右值时是一个指向100号内存的指针常量；但是它不可以作为左值，因为我们无法定位一个存放该表达式结果的内存。

#### 算术运算

标准中定义指针可以有如下几种算术运算：

* 指针 +/- 整数：用于指向数组中某个元素的指针，其运算结果是指针类型；但是此时如果出现了超过了数组长度的范围，可能会出现错误。
* 指针 - 指针：当两个指针各自为指向同一个数组的元素时才可以。对于其他情况，其结果是未定义的。

根据对于算术运算的限制，可知如下的几种非法写法：

```c
int a = 100, *b = &a;
b ++;
b --;
++ b;
-- b;
b + 100;
// 以上几种都是指针类型与整数类型的加减，而指针并不是指向数组的元素的指针，所以非法；上面的操作只是移动指针并没有任何问题，但是如果对一个非法指针结果执行间接访问操作，就可能报错。
```

> 注意：指针运算时会自动调节“一步的大小”，比如a是一个int型指针，且int占4个字节，当前a的值为0，那么a + 1的值为4；而如果a为char型指针，char占1个字节，那么a+1的值为1.
>
> 上述的运算本身都是没有问题的，适用于任何情况，与整数相加减用来表示一个新的指针指向；指针之间相减用来表示两个指针所指向的内存之间的距离。但是，虽然本身操作没问题，但是其结果可能是无意义的。

### 3. 指针与数组

数组名是一个指针常量！！注意，是一个常量！！所以，其不能作为左值使用。只有sizeof和&两种操作符时，数组名才不会被当做一个指针常量。

> sizeof操作符只有在直接作用与数组名时才不会将其作为一个指针常量，而是返回数组的长度；但是，如果定义了一个指针变量，该变量初始化时使用的是数组名，那么对该指针变量执行sizeof操作将不会得到数组的长度。

在C语言中，**下标引用和间接访问表达式**是一样的：

```c
int array[10];
int *a = array + 2;     // a = &array[2]
int b = a[2];    // 此时a是指向数组的指针，所以a[2]是合法的，其等价于*(a + 2)
a[-1];       // 这里就体现了采用指针变量的形式访问数组时的优势了，此时相当于往前移动一个位置*(a - 1)
```

因此，指针变量使用下标访问操作时，要注意是可以的，其具体的结果需要转化成**(point_name + index)**所表示的最终的下标才行。

```c
int (*p)[length]
```

上述代码用于声明一个指向整型数组的指针，之所以提这个是因为对于一维数组来说，其作为函数的形参时可以是一个指向数组元素类型的指针、也可以是一个数组形式；但是，对于二维数组来说，其形参如果想用指针表示的话，指针的指向类型需要时第二维度所需长度的数组。

> 正因为在数组中，下标引用与指针操作是等价的，因此在C语言中，没法对数组越界的情况做检查，也就是说如果想要通过name[i]去修改一个超出数组元素范围的内存区域是完全可以的，同样这也是非常危险的、是禁止的！

在声明函数原型的时候，形参为数组和指针时等价的：

```c
int abc(char *a);
int abc(char a[]);
// 上面两种函数原型是等价的
```



### 4. 指针与字符串

在C语言中，**字符串是零个或多个字符，并且以NUL字节结尾**（但是这个字符不算入字符串的长度内）。

### 5. 指针的高级声明

指针还有更高级的声明方式，如下：

```c
int *(*f)();
int **f();
```

上面的两种声明中，第一个f是一个函数指针，该函数的返回值类型是int指针；第二个f是一个函数，该函数的返回值是一个二级指针。

#### C的声明的解释

```c
int f;
int *f;
int* a, b;
```

对于第一个声明，f被声明为一个int型变量；而对于第二个声明，由于间接访问运算符的优先级高，所以**表达式(^f)(PS:这里的^代表间接访问运算符)被声明为一个int型数据！！**因此，f就是一个int指针；这种解释可以通过第三个声明来证实，其中a的最终类型是一个int指针，而b就是一个int变量。

因此，C语言中关于指针的高级声明的关键就在于：**将标识符的形式看作一个表达式，按照表达式的优先级逐个解释**；表达式的优先级为：**()>取下标运算=函数运算>间接访问操作符**。接下来就看看几个例子体会一下这句话：

```c
int f();  
int *f();
int (*f)();
int *(*f)();
```

第一个声明很简单，f首先进行函数运算，函数运算的结果是一个int型，所以f的类型就是一个返回值类型为int的函数；第二个声明，由于函数运算的优先级较高，所以f首先是一个函数，在之后对表达式f()也就是函数运算的结果F进行间接访问操作，因此F的类型是一个int型的指针，由于F是f()的结果，所以f的最终类型是一个返回值为int指针的函数；对于第三个声明，由于括号运算符的优先级最高，所以f首先是一个指向某种数据类型的指针，在之后可以看出这种数据类型是一个返回值类型为int的函数，因此f的最终数据类型为一个指向返回值为int型函数的函数指针;据此，第四种声明中f的最终类型为一个指向返回值类型为int指针的函数的函数指针。类似于函数运算的还有数组的下标访问操作符，这里就不在赘述了。

不过有以下两个声明是非法的：

```c
int f()[];
int f[]();
```

第一个，函数只能放回标量不能返回数组；第二个，因为函数可能有不同的长度，所以也是非法的。但是下面的是合法的：

```c
int *(*f[])();
```

f是一个数组，数组元素时函数指针，所指向的函数的返回值是一个int类型。

可以看到，**解释指针的高级声明的关键就在于将标识符看作一个表达式，按照表达式的优先级进行解释**。

### 6. 函数指针

函数原型必须出现在函数指针初始化之前，在C语言中，函数在调用时总是由编译器将其转化为一个函数指针，根据指针指定的内存位置开始执行代码。所以，对于一个函数指针来说，在调用时加不加间接访问操作符都可以：

```c
result = (*ptr)();
result = ptr();
```

上面的ptr是一个函数指针，上面的两种调用函数的方式都是正确的。

## 三、结构

除了数组之外，另一种常见的聚合数据类型就是结构了，数组聚合的是相同类型的数剧，而结构则可以聚合不同类型的数据。

### 1. 结构声明方式

结构的典型声明方式如下：

```c
struct tag{member-list} variable-list;
// 其中tag为结构标签，用来区分具有相同member-list的不同结构
// variable-list为声明该结构类型的变量
```

如果不存在相同成员列表的不同结构之间的冲突，或者想要一次性声明几个该结构类型的变量的话，上面的tag可以省略，设置了tag之后可以使用该tag随时随地声明该结构类型的变量，只不过和普通的int等不同的是，其前面要加struct关键字：

```c
struct tag variable_name;  // 前面还有struct关键字
```

上面需要使用struct关键字，还没发做到和普通的类型如int那样声明，想要做到像int那样一样声明结构类型的变量，需要另一种形式来定义结构：

```c
typedef struct{member-list} type_name; // 这里的type_name就如int一样代表结构类型的名称
type_name a, b, *c;   // 这样就可以做到像int a一样声明变量了
```

### 2. 结构成员的间接访问

对于一个指向某一个结构类型的指针，想要间接访问其内部的成员，必须如下进行操作：

```c
(*pointer).membername
```

针对于这种由于结构成员访问操作符优先级高于间接访问操作，所以提供了一种->操作符来完成这种工作：

```c
pointer->membername
```

关于结构在定义时的自引用问题，如果结构的某一个成员的类型是结构本身，那么这是非法的，因为一个结构在定义完全之前是不知道自己的长度的，而此时内部的成员如果也是自身类型的话，那么最终编译器不能够确定该类型的长度；但是，如果内部成员是指向自身类型的指针的话，是合法的，因为不管是指向何类型的指针，其长度是固定的。

```c
struct A {
    int aa;
    struct A b;     // 非法操作
} test;       

struct A {
    int aa;
    struct A *b;    // 合法操作
}
```

### 3. 结构的存储分配

正常来说结构的成员之间是紧挨着存储的，但是如果编译器有边界对其要求的话，成员之间极可能有很多填充的部分，因此我们在定义结构类型的时候，不同类型的成员的书写顺序有时候需要慎重的考虑一下，从而节省内存空间；一个通用的规则是，对边界对齐要求最弱的放在后面书写，比如char类型长度为1个字节，没有边界对齐的要求，放到member-list的最后。



## 四、动态内存分配

malloc用来从内存池中申请特定大小的连续内存；free用来释放从内存池中动态申请得到的内存。

### 1. malloc、calloc、realloc

三个函数的原型如下：

```c
void *malloc(size_t size);
void *calloc(size_t num_elements, size_t new_size);
void realloc(void *ptr, size_t new_size);
```

malloc申请到的内存时连续的内存，当申请失败(通常是内存不够)时返回一个NULL指针，因此，在调用malloc函数时，务必检查返回的是不是一个NULL指针。如果申请成功，**malloc返回的是一个void类型的指针**。

而calloc函数也是申请动态内存，只不过其大小的计算方式为两个形参的乘积；再者，calloc会自动为每一个元素初始化为零值；

而realloc函数的作用是修改参数ptr所代表的动态内存区域的大小，如果ptr的大小无法改变，则另行分配一个正确大小的内存，将原来的内容复制过来。

> 注：**上述分配函数通常用sbrk(2)系统调用来实现，该系统调用扩充或缩小进程的堆**

### 2. free

该方法用来释放malloc或者calloc方法申请的动态内存，其参数必须是上面两个方法的返回指针：

```c
void free(void *ptr);
```

> 注：**释放的内存会被保持在malloc池中，而不是返回给内核**

## 五、预处理器

### 1. define

#### 符号替换

define最常见的是符号替换,其**格式为：define name stuff，意义是将代码中所有的name在编译时都替换为stuff**。

```c
#define reg register;
```

#### 宏

宏和符号替换最大的不同就在于，**宏可以实现处理带参数的替换**。其**格式为：define name(parameter-list) stuff；在编写源代码的时候parameter-list可以是任何合法的符号**

```c
#define SQUARE(x) x * x
```

通过宏我们可以做到一些简单的处理，而且和函数相比，**宏的参数是类型无关的，只要符合stuff的操作要求即可**。

#### 移除宏

预处理指令undef用来移除一个宏定义：

```c
#undef name
```

### 2. include

include指令使另一个文件的内容被编译，这种替换方式很简单：预处理器删除这条指令，并用包含文件的内容取而代之。因此如果一个头文件被包含到多个源文件中，那么它实际上被编译了很多次。

有两种不同的文件包含：函数库文件与本地文件。

```c
#include <filename>      // 用于函数库文件
#include "filename"      // 用于本地文件
```



## 五、杂项

1. getchar()从标准输入中读取一个字符；如果不再存在任何字符，则会返回EOF
2. a = a + (expression)这个表达式中左操作数会被执行两次；而a += (expression)中只会被执行一次



